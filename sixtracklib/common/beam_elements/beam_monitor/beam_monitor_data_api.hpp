#ifndef SIXTRACKLIB_COMMON_BEAM_ELEMENTS_BEAM_MONITOR_BEAM_MONITOR_DATA_API_CXX_HPP__
#define SIXTRACKLIB_COMMON_BEAM_ELEMENTS_BEAM_MONITOR_BEAM_MONITOR_DATA_API_CXX_HPP__

#if !defined( SIXTRL_NO_INCLUDES )
    #include "sixtracklib/common/beam_elements/beam_monitor/beam_monitor_data.hpp"
    #include "sixtracklib/common/internal/type_store_traits.hpp"
#endif /* !defined( SIXTRL_NO_INCLUDES ) */

#if defined( __cplusplus )
namespace SIXTRL_CXX_NAMESPACE
{
    /* ********************************************************************* */
    /** SixTrackLib: Add autogenerated C++ API */
    /* ********************************************************************* */

    /* init API: */

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN
    SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
    BeamMonitor_preset( SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem );

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN void BeamMonitor_init( SIXTRL_BE_ARGPTR_DEC
        BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem );

    template< class R, class I, arch_size_t IAlign,
              typename NumStoresArg, typename StartTurnArg, typename SkipArg,
              typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
    SIXTRL_STATIC SIXTRL_FN void BeamMonitor_init_detailed( SIXTRL_BE_ARGPTR_DEC
            BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
        OutAddrArg out_address,
        ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
        FlagArg is_rolling, FlagArg is_turn_ordered );

    template< class R, class I, arch_size_t IAlign,
              typename NumStoresArg, typename StartTurnArg, typename SkipArg,
              typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
    SIXTRL_STATIC SIXTRL_FN void BeamMonitor_init( SIXTRL_BE_ARGPTR_DEC
            BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
        OutAddrArg out_address,
        ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
        FlagArg is_rolling, FlagArg is_turn_ordered );

    /* getter API, ptr argument: */

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_num_stores( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_start_turn(
        SIXTRL_BE_ARGPTR_DEC const BeamMonitorData< R, I, IAlign > *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_skip_turns( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN ::NS(belem_address_t) BeamMonitor_out_address(
        SIXTRL_BE_ARGPTR_DEC const BeamMonitorData< R, I, IAlign > *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_min_particle_id( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_max_particle_id( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN ::NS(be_monitor_flag_t)
    BeamMonitor_is_rolling_flag( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN ::NS(be_monitor_flag_t)
    BeamMonitor_is_turn_ordered_flag( SIXTRL_BE_ARGPTR_DEC const
        BeamMonitorData< R, I, IAlign > *const SIXTRL_RESTRICT elem
    ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN bool BeamMonitor_is_rolling(
        SIXTRL_BE_ARGPTR_DEC const BeamMonitorData< R, I, IAlign > *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN bool BeamMonitor_is_turn_ordered(
        SIXTRL_BE_ARGPTR_DEC const BeamMonitorData< R, I, IAlign > *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    /* getter API, ref argument: */

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN SIXTRL_PARTICLE_SET_ARGPTR_DEC
        typename TypeMethodParamTraits< typename BeamMonitorTraits<
            BeamMonitorData< R, I, IAlign > >::particle_set_t
                >::const_pointer
    BeamMonitor_const_particle_set( SIXTRL_BE_ARGPTR_DEC const
        BeamMonitorData< R, I, IAlign > *const SIXTRL_RESTRICT elem
    ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN SIXTRL_PARTICLE_SET_ARGPTR_DEC
        typename TypeMethodParamTraits< typename BeamMonitorTraits<
            BeamMonitorData< R, I, IAlign > >::particle_set_t >::pointer
    BeamMonitor_particle_set( SIXTRL_BE_ARGPTR_DEC
        BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem
    ) SIXTRL_NOEXCEPT;

    /* setter API, ptr argument: */

    template< class R, class I, arch_size_t IAlign, typename NumStoresArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_num_stores(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, NumStoresArg num_stores );

    template< class R, class I, arch_size_t IAlign, typename StartTurnArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_start_turn(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, StartTurnArg start_turn );

    template< class R, class I, arch_size_t IAlign, typename SkipArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_skip_turns(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, SkipArg skip_turns );

    template< class R, class I, arch_size_t IAlign, typename OutAddrArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_out_address(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, OutAddrArg out_address );

    template< class R, class I, arch_size_t IAlign, typename ParticleIdArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_min_particle_id(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, ParticleIdArg min_particle_id );

    template< class R, class I, arch_size_t IAlign, typename ParticleIdArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_max_particle_id(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, ParticleIdArg max_particle_id );

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_is_rolling_flag(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem,
        ::NS(be_monitor_flag_t) const is_rolling_flag ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_is_turn_ordered_flag(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem,
        ::NS(be_monitor_flag_t) const is_turn_ordered ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_is_rolling(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, bool const is_rolling ) SIXTRL_NOEXCEPT;

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_is_turn_ordered(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, bool const is_turn_ordered ) SIXTRL_NOEXCEPT;
}

/* init API: */

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN
SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
NS(BeamMonitor_preset)( SIXTRL_BE_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN void NS(BeamMonitor_init)( SIXTRL_BE_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign >* SIXTRL_RESTRICT elem );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename NumStoresArg, typename StartTurnArg, typename SkipArg,
          typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
SIXTRL_STATIC SIXTRL_FN void NS(BeamMonitor_init_detailed)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign >* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
    OutAddrArg out_address,
    ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
    FlagArg is_rolling, FlagArg is_turn_ordered );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename NumStoresArg, typename StartTurnArg, typename SkipArg,
          typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
SIXTRL_STATIC SIXTRL_FN void NS(BeamMonitor_init)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign >* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
    OutAddrArg out_address,
    ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
    FlagArg is_rolling, FlagArg is_turn_ordered );

/* getter API, ptr argument: */

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
NS(BeamMonitor_num_stores)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
NS(BeamMonitor_start_turn)(
    SIXTRL_BE_ARGPTR_DEC const SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
        >::particle_index_t >::const_existing_type
NS(BeamMonitor_skip_turns)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN ::NS(belem_address_t) NS(BeamMonitor_out_address)(
    SIXTRL_BE_ARGPTR_DEC const SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
NS(BeamMonitor_min_particle_id)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
NS(BeamMonitor_max_particle_id)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN ::NS(be_monitor_flag_t)
NS(BeamMonitor_is_rolling_flag)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN ::NS(be_monitor_flag_t)
NS(BeamMonitor_is_turn_ordered_flag)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN bool NS(BeamMonitor_is_rolling)(
    SIXTRL_BE_ARGPTR_DEC const SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN bool NS(BeamMonitor_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC const SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

/* getter API, ref argument: */

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN SIXTRL_PARTICLE_SET_ARGPTR_DEC
    typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
        typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
            SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
                >::particle_set_t >::const_pointer
NS(BeamMonitor_const_particle_set)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN SIXTRL_PARTICLE_SET_ARGPTR_DEC
    typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
        typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
            SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
                >::particle_set_t >::pointer
NS(BeamMonitor_particle_set)( SIXTRL_BE_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

/* setter API, ptr argument: */

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename NumStoresArg >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_num_stores)( SIXTRL_BE_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, NumStoresArg num_stores );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename StartTurnArg >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_start_turn)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign >* SIXTRL_RESTRICT elem, StartTurnArg start_turn );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename SkipArg >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
    NS(BeamMonitor_set_skip_turns)( SIXTRL_BE_ARGPTR_DEC
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, SkipArg skip_turns );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename OutAddrArg >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_out_address)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, OutAddrArg out_address );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename ParticleIdArg >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, ParticleIdArg min_particle_id );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename ParticleIdArg >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_max_particle_id)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, ParticleIdArg max_particle_id );

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_is_rolling_flag)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem,
    ::NS(be_monitor_flag_t) const is_rolling_flag ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_is_turn_ordered_flag)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem,
    ::NS(be_monitor_flag_t) const is_turn_ordered ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_is_rolling)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, bool const is_rolling ) SIXTRL_NOEXCEPT;

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_STATIC SIXTRL_FN SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, bool const is_turn_ordered ) SIXTRL_NOEXCEPT;

#endif /* defined( __cplusplus ) */

/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
/* !!!!!!!        Inline Methods and Functions Implementations       !!!!!!!! */
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

#if defined( __cplusplus )
namespace SIXTRL_CXX_NAMESPACE
{
    /* ********************************************************************* */
    /** SixTrackLib: Add autogenerated C++ API */
    /* ********************************************************************* */

    /* init API: */

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
    BeamMonitor_preset( SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem )
    {
        namespace st = SIXTRL_CXX_NAMESPACE;

        using index_t = typename BeamMonitorTraits<
            BeamMonitorData< R, I, IAlign > >::particle_index_t;

        if( elem != SIXTRL_NULLPTR )
        {
            st::BeamMonitor_set_num_stores( elem, index_t{ 0 } );
            st::BeamMonitor_set_start_turn( elem, index_t{ 0 } );
            st::BeamMonitor_set_skip_turns( elem, index_t{ 0 } );
            st::BeamMonitor_set_out_address( elem, ::NS(belem_address_t){0} );
            st::BeamMonitor_set_min_particle_id( elem, index_t{ 0 } );
            st::BeamMonitor_set_max_particle_id( elem, index_t{ 0 } );

            st::BeamMonitor_set_is_rolling_flag(
                elem, ::NS(be_monitor_flag_t){ 0 } );

            st::BeamMonitor_set_is_turn_ordered_flag(
                elem, ::NS(be_monitor_flag_t){ 0 } );
        }

        return elem;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE void BeamMonitor_init( SIXTRL_BE_ARGPTR_DEC
        BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem )
    {
        SIXTRL_CXX_NAMESPACE::BeamMonitor_preset( elem );
    }

    template< class R, class I, arch_size_t IAlign,
              typename NumStoresArg, typename StartTurnArg, typename SkipArg,
              typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
    SIXTRL_INLINE void BeamMonitor_init_detailed( SIXTRL_BE_ARGPTR_DEC
            BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
        OutAddrArg out_address,
        ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
        FlagArg is_rolling, FlagArg is_turn_ordered )
    {
        namespace st = SIXTRL_CXX_NAMESPACE;
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );

        st::BeamMonitor_set_num_stores( elem, num_stores );
        st::BeamMonitor_set_start_turn( elem, start_turn );
        st::BeamMonitor_set_skip_turns( elem, skip_turns );
        st::BeamMonitor_set_out_address( elem, out_address );
        st::BeamMonitor_set_min_particle_id( elem, min_particle_id );
        st::BeamMonitor_set_max_particle_id( elem, max_particle_id );
        st::BeamMonitor_set_is_rolling_flag( elem, is_rolling );
        st::BeamMonitor_set_is_turn_ordered_flag( elem, is_turn_ordered );
    }

    template< class R, class I, arch_size_t IAlign,
              typename NumStoresArg, typename StartTurnArg, typename SkipArg,
              typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
    SIXTRL_INLINE void BeamMonitor_init( SIXTRL_BE_ARGPTR_DEC
            BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
        OutAddrArg out_address,
        ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
        FlagArg is_rolling, FlagArg is_turn_ordered )
    {
        SIXTRL_CXX_NAMESPACE::BeamMonitor_init_detailed( elem, num_stores,
            start_turn, skip_turns, out_address, min_particle_id,
                max_particle_id, is_rolling, is_turn_ordered );
    }

    /* getter API, ptr argument: */

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_num_stores( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->num_stores;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_start_turn(
        SIXTRL_BE_ARGPTR_DEC const BeamMonitorData< R, I, IAlign > *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->start_turn;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_skip_turns( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->skip_turns;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE ::NS(belem_address_t) BeamMonitor_out_address(
        SIXTRL_BE_ARGPTR_DEC const BeamMonitorData< R, I, IAlign > *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->out_address;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_min_particle_id( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->min_particle_id;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE typename TypeMethodParamTraits<
        typename BeamMonitorTraits< BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
    BeamMonitor_max_particle_id( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->max_particle_id;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE ::NS(be_monitor_flag_t)
    BeamMonitor_is_rolling_flag( SIXTRL_BE_ARGPTR_DEC const BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->is_rolling_flag;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE ::NS(be_monitor_flag_t)
    BeamMonitor_is_turn_ordered_flag( SIXTRL_BE_ARGPTR_DEC const
        BeamMonitorData< R, I, IAlign > *const SIXTRL_RESTRICT elem
    ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->is_turn_ordered_flag;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE bool BeamMonitor_is_rolling(
        SIXTRL_BE_ARGPTR_DEC const BeamMonitorData< R, I, IAlign > *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return ( elem->is_rolling_flag == ::NS(be_monitor_flag_t){ 1 } );
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE bool BeamMonitor_is_turn_ordered(
        SIXTRL_BE_ARGPTR_DEC const BeamMonitorData< R, I, IAlign > *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return ( elem->is_turn_ordered_flag == ::NS(be_monitor_flag_t){ 1 } );
    }

    /* getter API, ref argument: */

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE SIXTRL_PARTICLE_SET_ARGPTR_DEC
        typename TypeMethodParamTraits< typename BeamMonitorTraits<
            BeamMonitorData< R, I, IAlign > >::particle_set_t
                >::const_pointer
    BeamMonitor_const_particle_set( SIXTRL_BE_ARGPTR_DEC const
        BeamMonitorData< R, I, IAlign > *const SIXTRL_RESTRICT elem
    ) SIXTRL_NOEXCEPT
    {
        using particle_set_t = typename BeamMonitorTraits<
            BeamMonitorData< R, I, IAlign > >::particle_set_t;

        using ptr_pset_t = typename TypeMethodParamTraits<
            particle_set_t >::const_pointer;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return reinterpret_cast< SIXTRL_PARTICLE_SET_ARGPTR_DEC ptr_pset_t >(
            static_cast< std::uintptr_t >( elem->out_address ) );
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE SIXTRL_PARTICLE_SET_ARGPTR_DEC
        typename TypeMethodParamTraits< typename BeamMonitorTraits<
            BeamMonitorData< R, I, IAlign > >::particle_set_t >::pointer
    BeamMonitor_particle_set( SIXTRL_BE_ARGPTR_DEC
        BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem
    ) SIXTRL_NOEXCEPT
    {
        using particle_set_t = typename BeamMonitorTraits<
            BeamMonitorData< R, I, IAlign > >::particle_set_t;

        using ptr_pset_t = typename TypeMethodParamTraits<
            particle_set_t >::pointer;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return reinterpret_cast< SIXTRL_PARTICLE_SET_ARGPTR_DEC ptr_pset_t >(
            static_cast< std::uintptr_t >( elem->out_address ) );
    }

    /* setter API, ptr argument: */

    template< class R, class I, arch_size_t IAlign, typename NumStoresArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_num_stores(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, NumStoresArg num_stores )
    {
        typedef typename std::decay< NumStoresArg >::type src_t;
        typedef typename BeamMonitorTraits< BeamMonitorData<
            R, I, IAlign > >::particle_index_t dest_t;

        SIXTRL_ASSSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment<
            src_t, dest_t >( elem->num_stores, num_stores );
    }

    template< class R, class I, arch_size_t IAlign, typename StartTurnArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_start_turn(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, StartTurnArg start_turn )
    {
        typedef typename std::decay< StartTurnArg >::type src_t;
        typedef typename BeamMonitorTraits< BeamMonitorData<
            R, I, IAlign > >::particle_index_t dest_t;

        SIXTRL_ASSSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment<
            src_t, dest_t >( elem->start_turn, start_turn );
    }

    template< class R, class I, arch_size_t IAlign, typename SkipArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_skip_turns(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, SkipArg skip_turns )
    {
        typedef typename std::decay< SkipArg >::type src_t;
        typedef typename BeamMonitorTraits< BeamMonitorData<
            R, I, IAlign > >::particle_index_t dest_t;

        SIXTRL_ASSSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment<
            src_t, dest_t >( elem->skip_turns, skip_turns );
    }

    template< class R, class I, arch_size_t IAlign, typename OutAddrArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_out_address(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, OutAddrArg out_address )
    {
        typedef typename std::decay< OutAddrArg >::type src_t;
        typedef ::NS(belem_address_t) dest_t;

        SIXTRL_ASSSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment<
            src_t, dest_t >( elem->out_address, out_address );
    }

    template< class R, class I, arch_size_t IAlign, typename ParticleIdArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_min_particle_id(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, ParticleIdArg min_particle_id )
    {
        typedef typename std::decay< ParticleIdArg >::type src_t;
        typedef typename BeamMonitorTraits< BeamMonitorData<
            R, I, IAlign > >::particle_index_t dest_t;

        SIXTRL_ASSSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment<
            src_t, dest_t >( elem->max_particle_id, min_particle_id );
    }

    template< class R, class I, arch_size_t IAlign, typename ParticleIdArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_max_particle_id(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, ParticleIdArg max_particle_id )
    {
        typedef typename std::decay< ParticleIdArg >::type src_t;
        typedef typename BeamMonitorTraits< BeamMonitorData<
            R, I, IAlign > >::particle_index_t dest_t;

        SIXTRL_ASSSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment<
            src_t, dest_t >( elem->max_particle_id, max_particle_id );
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_is_rolling_flag(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem,
        ::NS(be_monitor_flag_t) const is_rolling_flag ) SIXTRL_NOEXCEPT
    {
        namespace st = SIXTRL_CXX_NAMESPACE;
        st::arch_status_t status = st::ARCH_STATUS_GENERAL_FAILURE;

        if( elem != SIXTRL_NULLPTR )
        {
            elem->is_rolling_flag = is_rolling_flag;
            status = st::ARCH_STATUS_SUCCESS;
        }

        return status;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_is_turn_ordered_flag(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem,
        ::NS(be_monitor_flag_t) const is_turn_ordered_flag ) SIXTRL_NOEXCEPT
    {
        namespace st = SIXTRL_CXX_NAMESPACE;
        st::arch_status_t status = st::ARCH_STATUS_GENERAL_FAILURE;

        if( elem != SIXTRL_NULLPTR )
        {
            elem->is_turn_ordered_flag = is_turn_ordered_flag;
            status = st::ARCH_STATUS_SUCCESS;
        }

        return status;
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_is_rolling(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, bool const is_rolling ) SIXTRL_NOEXCEPT
    {
        using flag_t = ::NS(be_monitor_flag_t);
        return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_is_rolling_flag(
            elem, ( is_rolling ) ? flag_t{ 1 } : flag_t{ 0 } );
    }

    template< class R, class I, arch_size_t IAlign >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_is_turn_ordered(
        SIXTRL_BE_ARGPTR_DEC BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, bool const is_turn_ordered ) SIXTRL_NOEXCEPT
    {
        using flag_t = ::NS(be_monitor_flag_t);
        return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_is_turn_ordered_flag(
            elem, ( is_turn_ordered ) ? flag_t{ 1 } : flag_t{ 0 } );
    }
}

/* init API: */

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData<
    R, I, IAlign >* NS(BeamMonitor_preset)( SIXTRL_BE_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >* SIXTRL_RESTRICT elem )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_preset( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE void NS(BeamMonitor_init)( SIXTRL_BE_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign >* SIXTRL_RESTRICT elem )
{
    SIXTRL_CXX_NAMESPACE::BeamMonitor_init( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename NumStoresArg, typename StartTurnArg, typename SkipArg,
          typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
SIXTRL_INLINE void NS(BeamMonitor_init_detailed)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign >* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
    OutAddrArg out_address,
    ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
    FlagArg is_rolling, FlagArg is_turn_ordered )
{
    SIXTRL_CXX_NAMESPACE::BeamMonitor_init_detailed( elem, num_stores,
        start_turn, skip_turns, out_address, min_particle_id, max_particle_id,
            is_rolling, is_turn_ordered );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename NumStoresArg, typename StartTurnArg, typename SkipArg,
          typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
SIXTRL_INLINE void NS(BeamMonitor_init)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign >* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
    OutAddrArg out_address,
    ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
    FlagArg is_rolling, FlagArg is_turn_ordered )
{
    SIXTRL_CXX_NAMESPACE::BeamMonitor_init( elem, num_stores, start_turn,
        skip_turns, out_address, min_particle_id, max_particle_id,
            is_rolling, is_turn_ordered );
}

/* getter API, ptr argument: */

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
NS(BeamMonitor_num_stores)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_num_stores( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
NS(BeamMonitor_start_turn)(
    SIXTRL_BE_ARGPTR_DEC const SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_start_turn( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
        >::particle_index_t >::const_existing_type
NS(BeamMonitor_skip_turns)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_skip_turns( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE ::NS(belem_address_t) NS(BeamMonitor_out_address)(
    SIXTRL_BE_ARGPTR_DEC const SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_out_address( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
NS(BeamMonitor_min_particle_id)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_min_particle_id( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
    typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
            >::particle_index_t >::const_existing_type
NS(BeamMonitor_max_particle_id)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_max_particle_id( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE ::NS(be_monitor_flag_t)
NS(BeamMonitor_is_rolling_flag)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_is_rolling_flag( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE ::NS(be_monitor_flag_t)
NS(BeamMonitor_is_turn_ordered_flag)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_is_turn_ordered_flag( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE bool NS(BeamMonitor_is_rolling)(
    SIXTRL_BE_ARGPTR_DEC const SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_is_rolling( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE bool NS(BeamMonitor_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC const SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign > *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_is_turn_ordered( elem );
}

/* getter API, ref argument: */

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE SIXTRL_PARTICLE_SET_ARGPTR_DEC
    typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
        typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
            SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
                >::particle_set_t >::const_pointer
NS(BeamMonitor_const_particle_set)( SIXTRL_BE_ARGPTR_DEC const
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign > *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_const_particle_set( elem );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE SIXTRL_PARTICLE_SET_ARGPTR_DEC
    typename SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
        typename SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
            SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >
                >::particle_set_t >::pointer
NS(BeamMonitor_particle_set)( SIXTRL_BE_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_particle_set( elem );
}

/* setter API, ptr argument: */

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename NumStoresArg >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_num_stores)( SIXTRL_BE_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, NumStoresArg num_stores )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_num_stores(
        elem, num_stores );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename StartTurnArg >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_start_turn)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData<
        R, I, IAlign >* SIXTRL_RESTRICT elem, StartTurnArg start_turn )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_start_turn(
        elem, start_turn );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename SkipArg >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
    NS(BeamMonitor_set_skip_turns)( SIXTRL_BE_ARGPTR_DEC
        SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
            SIXTRL_RESTRICT elem, SkipArg skip_turns )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_skip_turns(
        elem, skip_turns );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename OutAddrArg >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_out_address)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, OutAddrArg out_address )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_out_address(
        elem, out_address );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename ParticleIdArg >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, ParticleIdArg min_particle_id )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_min_particle_id(
        elem, min_particle_id );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign,
          typename ParticleIdArg >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_max_particle_id)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, ParticleIdArg max_particle_id )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_max_particle_id(
        elem, max_particle_id );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_is_rolling_flag)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem,
    ::NS(be_monitor_flag_t) const is_rolling_flag ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_is_rolling_flag(
        elem, is_rolling_flag );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_is_turn_ordered_flag)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem,
    ::NS(be_monitor_flag_t) const is_turn_ordered_flag ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_is_turn_ordered_flag(
        elem, is_turn_ordered_flag );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_is_rolling)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, bool const is_rolling ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_is_rolling(
        elem, is_rolling );
}

template< class R, class I, SIXTRL_CXX_NAMESPACE::arch_size_t IAlign >
SIXTRL_INLINE SIXTRL_CXX_NAMESPACE::arch_status_t
NS(BeamMonitor_set_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC SIXTRL_CXX_NAMESPACE::BeamMonitorData< R, I, IAlign >*
        SIXTRL_RESTRICT elem, bool const is_turn_ordered ) SIXTRL_NOEXCEPT
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_is_turn_ordered(
        elem, is_turn_ordered );
}

#endif /* defined( __cplusplus ) */

#endif /* SIXTRACKLIB_COMMON_BEAM_ELEMENTS_BEAM_MONITOR_BEAM_MONITOR_DATA_API_CXX_HPP__ */
