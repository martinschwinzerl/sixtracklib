#ifndef SIXTRACKLIB_COMMON_BEAM_ELEMENTS_BEAM_MONITOR_BEAM_MONITOR_API_H__
#define SIXTRACKLIB_COMMON_BEAM_ELEMENTS_BEAM_MONITOR_BEAM_MONITOR_API_H__

#if !defined( SIXTRL_NO_INCLUDES )
    #include "sixtracklib/common/beam_elements/beam_monitor/beam_monitor.h"
    #include "sixtracklib/common/particles/particle_set.h"
    #include "sixtracklib/common/internal/type_store_traits.hpp"
#endif /* !defined( SIXTRL_NO_INCLUDES ) */

#if defined( __cplusplus )
namespace SIXTRL_CXX_NAMESPACE
{
    /* ********************************************************************* */
    /** SixTrackLib: Add autogenerated C++ API */
    /* ********************************************************************* */

    /* init API: */

    SIXTRL_STATIC SIXTRL_FN SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)*
    BeamMonitor_preset( SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)*
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN void BeamMonitor_init( SIXTRL_BE_ARGPTR_DEC
        ::NS(BeamMonitor)* SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    template< typename NumStoresArg, typename StartTurnArg, typename SkipArg,
              typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
    SIXTRL_STATIC SIXTRL_FN void BeamMonitor_init_detailed(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
        OutAddrArg out_address,
        ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
        FlagArg is_rolling, FlagArg is_turn_ordered );

    template< typename NumStoresArg, typename StartTurnArg, typename SkipArg,
              typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
    SIXTRL_STATIC SIXTRL_FN void BeamMonitor_init(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
        OutAddrArg out_address,
        ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
        FlagArg is_rolling, FlagArg is_turn_ordered );

    /* getter API, ptr argument: */

    SIXTRL_STATIC SIXTRL_FN ::NS(particle_index_t) BeamMonitor_num_stores(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN ::NS(particle_index_t) BeamMonitor_start(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN ::NS(particle_index_t) BeamMonitor_skip(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN ::NS(belem_address_t) BeamMonitor_out_address(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN ::NS(particle_index_t) BeamMonitor_min_particle_id(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN ::NS(particle_index_t) BeamMonitor_max_particle_id(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN ::NS(be_monitor_flag_t)
    BeamMonitor_is_rolling_flag( SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor)
        *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN ::NS(be_monitor_flag_t)
    BeamMonitor_is_turn_ordered_flag( SIXTRL_BE_ARGPTR_DEC const
        ::NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN bool BeamMonitor_is_rolling(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN bool BeamMonitor_is_turn_ordered(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    /* getter API, ref argument: */

    SIXTRL_STATIC SIXTRL_FN SIXTRL_PARTICLE_SET_ARGPTR_DEC
        typename TypeMethodParamTraits< typename BeamMonitorTraits<
            ::NS(BeamMonitor) >::particle_set_t >::const_pointer
    BeamMonitor_const_particle_set( SIXTRL_BE_ARGPTR_DEC const
        ::NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN SIXTRL_PARTICLE_SET_ARGPTR_DEC
        typename TypeMethodParamTraits< typename BeamMonitorTraits<
            ::NS(BeamMonitor) >::particle_set_t >::pointer
    BeamMonitor_particle_set( SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)*
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

    /* setter API, ptr argument: */

    template< typename NumStoresArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_num_stores(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores );

    template< typename StartTurnArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_start_turn(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        StartTurnArg start_turn );

    template< typename SkipArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_skip_turns(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        SkipArg skip_turns );

    template< typename OutAddrArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_out_address(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        OutAddrArg out_address );

    template< typename ParticleIdArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_min_particle_id(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        ParticleIdArg min_particle_id );

    template< typename ParticleIdArg >
    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_max_particle_id(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        ParticleIdArg max_particle_id );

    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_is_rolling_flag(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        ::NS(be_monitor_flag_t) const is_rolling_flag ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_is_turn_ordered_flag(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        ::NS(be_monitor_flag_t) const is_turn_ordered ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_is_rolling(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        bool const is_rolling_flag ) SIXTRL_NOEXCEPT;

    SIXTRL_STATIC SIXTRL_FN arch_status_t BeamMonitor_set_is_turn_ordered(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        bool const is_turn_ordered ) SIXTRL_NOEXCEPT;
}
#endif /* defined( __cplusplus ) */

#if defined( __cplusplus ) && !defined( _GPUCODE )
extern "C" {
#endif /* C++, Host */

/* init API, ptr argument */

SIXTRL_STATIC SIXTRL_FN SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)*
NS(BeamMonitor_preset)( SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)*
    SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN void NS(BeamMonitor_init)( SIXTRL_BE_ARGPTR_DEC
    NS(BeamMonitor)* SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN void NS(BeamMonitor_init_detailed)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t)  const num_stores,
    NS(particle_index_t)  const start_turn,
    NS(particle_index_t)  const skip_turns,
    NS(be_monitor_flag_t) const out_address,
    NS(particle_index_t)  const min_particle_id,
    NS(particle_index_t)  const max_particle_id,
    NS(be_monitor_flag_t) const is_rolling,
    NS(be_monitor_flag_t) const is_turn_ordered ) SIXTRL_NOEXCEPT;

#if defined( __cplusplus ) && !defined( _GPUCODE )
}
#endif /* C++, Host */

#if defined( __cplusplus )

template< typename NumStoresArg, typename StartTurnArg, typename SkipArg,
          typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
SIXTRL_STATIC SIXTRL_FN void NS(BeamMonitor_init_detailed)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
    OutAddrArg out_address,
    ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
    FlagArg is_rolling, FlagArg is_turn_ordered );

template< typename NumStoresArg, typename StartTurnArg, typename SkipArg,
          typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
SIXTRL_STATIC SIXTRL_FN void NS(BeamMonitor_init)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
    OutAddrArg out_address,
    ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
    FlagArg is_rolling, FlagArg is_turn_ordered );

#endif /* C++ */

#if defined( __cplusplus ) && !defined( _GPUCODE )
extern "C" {
#endif /* C++, Host */

/* getter API, ptr argument: */

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_num_stores)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_start_turn)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_skip_turns)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(belem_address_t) NS(BeamMonitor_out_address)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_max_particle_id)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(be_monitor_flag_t) NS(BeamMonitor_is_rolling_flag)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(be_monitor_flag_t)
NS(BeamMonitor_is_turn_ordered_flag)( SIXTRL_BE_ARGPTR_DEC const
    NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN bool NS(BeamMonitor_is_rolling)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN bool NS(BeamMonitor_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

/* getter API, ref argument: */

#if defined( __cplusplus )

SIXTRL_STATIC SIXTRL_FN SIXTRL_PARTICLE_SET_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorTraits< ::NS(BeamMonitor)
            >::particle_set_t >::const_pointer
NS(BeamMonitor_const_particle_set)( SIXTRL_BE_ARGPTR_DEC const
    ::NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN SIXTRL_PARTICLE_SET_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorTraits<
            ::NS(BeamMonitor) >::particle_set_t >::pointer
NS(BeamMonitor_particle_set)( SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)*
    SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

#endif /* C++ */

#if defined( __cplusplus ) && !defined( _GPUCODE )
}
#endif /* C++, Host */

/* setter API, ptr argument: */

#if defined( __cplusplus )

template< typename NumStoresArg >
SIXTRL_STATIC SIXTRL_FN ::NS(arch_status_t) NS(BeamMonitor_set_num_stores)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores );

template< typename StartTurnArg >
SIXTRL_STATIC SIXTRL_FN ::NS(arch_status_t) NS(BeamMonitor_set_start_turn)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    StartTurnArg start_turn );

template< typename SkipArg >
SIXTRL_STATIC SIXTRL_FN ::NS(arch_status_t) NS(BeamMonitor_set_skip_turns)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    SkipArg skip_turns );

template< typename OutAddrArg >
SIXTRL_STATIC SIXTRL_FN ::NS(arch_status_t) NS(BeamMonitor_set_out_address)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    OutAddrArg out_address );

template< typename ParticleIdArg >
SIXTRL_STATIC SIXTRL_FN ::NS(arch_status_t) NS(BeamMonitor_set_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    ParticleIdArg min_particle_id );

template< typename ParticleIdArg >
SIXTRL_STATIC SIXTRL_FN ::NS(arch_status_t) NS(BeamMonitor_set_max_particle_id)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    ParticleIdArg max_particle_id );

#endif /* C++ */

/* getter API, ptr argument: */

#if defined( __cplusplus ) && !defined( _GPUCODE )
extern "C" {
#endif /* C++, Host */

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_num_stores)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_start_turn)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_skip_turns)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(belem_address_t) NS(BeamMonitor_out_address)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(particle_index_t) NS(BeamMonitor_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(be_monitor_flag_t) NS(BeamMonitor_is_rolling_flag)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(be_monitor_flag_t)
NS(BeamMonitor_is_turn_ordered_flag)( SIXTRL_BE_ARGPTR_DEC const
    NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN bool NS(BeamMonitor_is_rolling)( SIXTRL_BE_ARGPTR_DEC
    const NS(BeamMonitor) *const SIXTRL_RESTRICT elem
) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN bool NS(BeamMonitor_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const SIXTRL_RESTRICT elem
) SIXTRL_NOEXCEPT;

/* setter API, ptr argument: */

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_num_stores)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const num_stores ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_start_turn)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const start_turn ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_skip_turns)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const skip_turns ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_out_address)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(belem_address_t) const out_address ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const min_particle_id ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_max_particle_id)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const max_particle_id ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_is_rolling_flag)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(be_monitor_flag_t) const is_rolling_flag ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_is_turn_ordered_flag)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(be_monitor_flag_t) const is_turn_ordered_flag ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_is_rolling)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    bool const is_rolling ) SIXTRL_NOEXCEPT;

SIXTRL_STATIC SIXTRL_FN NS(arch_status_t) NS(BeamMonitor_set_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    bool const is_turn_ordered ) SIXTRL_NOEXCEPT;

#if defined( __cplusplus ) && !defined( _GPUCODE )
}
#endif /* C++, Host */

/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
/* !!!!!!!        Inline Methods and Functions Implementations       !!!!!!!! */
/* !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */

#if defined( __cplusplus )
namespace SIXTRL_CXX_NAMESPACE
{
    /* ********************************************************************* */
    /** SixTrackLib: Add autogenerated C++ API */
    /* ********************************************************************* */

    /* init API: */

    SIXTRL_INLINE SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* BeamMonitor_preset(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem
    ) SIXTRL_NOEXCEPT
    {
        namespace st = SIXTRL_CXX_NAMESPACE;
        if( elem != SIXTRL_NULLPTR )
        {
            st::BeamMonitor_set_num_stores( elem,  st::particle_index_t{ 0 } );
            st::BeamMonitor_set_start_turn( elem,  st::particle_index_t{ 0 } );
            st::BeamMonitor_set_skip_turns( elem,  st::particle_index_t{ 0 } );
            st::BeamMonitor_set_out_address( elem, st::belem_address_t{ 0 } );

            st::BeamMonitor_set_min_particle_id(
                elem, st::particle_index_t{ 0 } );

            st::BeamMonitor_set_max_particle_id(
                elem, st::particle_index_t{ 0 } );

            st::BeamMonitor_set_is_rolling_flag(
                elem, st::be_monitor_flag_t{ 0 } );

            st::BeamMonitor_set_is_turn_ordered_flag(
                elem, st::be_monitor_flag_t{ 0 } );
        }

        return elem;
    }

    SIXTRL_INLINE void BeamMonitor_init( SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)*
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_CXX_NAMESPACE::BeamMonitor_preset( elem );
    }

    template< typename NumStoresArg, typename StartTurnArg, typename SkipArg,
              typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
    SIXTRL_INLINE void BeamMonitor_init_detailed(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
        OutAddrArg out_address,
        ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
        FlagArg is_rolling, FlagArg is_turn_ordered )
    {
        namespace st = SIXTRL_CXX_NAMESPACE;
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );

        st::BeamMonitor_set_num_stores( elem,  num_stores );
        st::BeamMonitor_set_start_turn( elem,  start_turn );
        st::BeamMonitor_set_skip_turns( elem,  skip_turns );
        st::BeamMonitor_set_out_address( elem, out_address );
        st::BeamMonitor_set_min_particle_id( elem, min_particle_id );
        st::BeamMonitor_set_max_particle_id( elem, max_particle_id );
        st::BeamMonitor_set_is_rolling_flag( elem, is_rolling );
        st::BeamMonitor_set_is_turn_ordered_flag( elem, is_turn_ordered );
    }

    template< typename NumStoresArg, typename StartTurnArg, typename SkipArg,
              typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
    SIXTRL_INLINE void BeamMonitor_init(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
        OutAddrArg out_address,
        ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
        FlagArg is_rolling, FlagArg is_turn_ordered )
    {
        SIXTRL_CXX_NAMESPACE::BeamMonitor_init_detailed( elem, num_stores,
            start_turn, skip_turns, out_address, min_particle_id,
                max_particle_id, is_rolling, is_turn_ordered );
    }

    /* getter API, ptr argument: */

    SIXTRL_INLINE ::NS(particle_index_t) BeamMonitor_num_stores(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->num_stores;
    }

    SIXTRL_INLINE ::NS(particle_index_t) BeamMonitor_start(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->start_turn;
    }

    SIXTRL_INLINE ::NS(particle_index_t) BeamMonitor_skip(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->skip_turns;
    }

    SIXTRL_INLINE ::NS(belem_address_t) BeamMonitor_out_address(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->out_address;
    }

    SIXTRL_INLINE ::NS(particle_index_t) BeamMonitor_min_particle_id(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->min_particle_id;
    }

    SIXTRL_INLINE ::NS(particle_index_t) BeamMonitor_max_particle_id(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->max_particle_id;
    }

    SIXTRL_INLINE ::NS(be_monitor_flag_t)
    BeamMonitor_is_rolling_flag( SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor)
        *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->is_rolling_flag;
    }

    SIXTRL_INLINE ::NS(be_monitor_flag_t)
    BeamMonitor_is_turn_ordered_flag( SIXTRL_BE_ARGPTR_DEC const
        ::NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return elem->is_turn_ordered_flag;
    }

    SIXTRL_INLINE bool BeamMonitor_is_rolling(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return ( elem->is_rolling_flag == ::NS(be_monitor_flag_t){ 1 } );
    }

    SIXTRL_INLINE bool BeamMonitor_is_turn_ordered(
        SIXTRL_BE_ARGPTR_DEC const ::NS(BeamMonitor) *const
            SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return ( elem->is_turn_ordered_flag == ::NS(be_monitor_flag_t){ 1 } );
    }

    /* getter API, ref argument: */

    SIXTRL_INLINE SIXTRL_PARTICLE_SET_ARGPTR_DEC TypeMethodParamTraits<
        typename BeamMonitorTraits< ::NS(BeamMonitor) >::particle_set_t
            >::const_pointer
    BeamMonitor_const_particle_set( SIXTRL_BE_ARGPTR_DEC const
        ::NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        typedef TypeMethodParamTraits< BeamMonitorTraits<
            ::NS(BeamMonitor) >::particle_set_t >::const_pointer ptr_generic_t;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return reinterpret_cast< SIXTRL_PARTICLE_SET_ARGPTR_DEC ptr_generic_t
            >( static_cast< std::uintptr_t >( elem->out_address ) );
    }

    SIXTRL_INLINE SIXTRL_PARTICLE_SET_ARGPTR_DEC TypeMethodParamTraits<
        BeamMonitorTraits< ::NS(BeamMonitor) >::particle_set_t >::pointer
    BeamMonitor_particle_set( SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)*
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
    {
        typedef typename TypeMethodParamTraits< typename BeamMonitorTraits<
            ::NS(BeamMonitor) >::particle_set_t >::pointer ptr_generic_t;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return reinterpret_cast< SIXTRL_PARTICLE_SET_ARGPTR_DEC ptr_generic_t
            >( static_cast< std::uintptr_t >( elem->out_address ) );
    }

    /* setter API, ptr argument: */

    template< typename NumStoresArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_num_stores(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        NumStoresArg num_stores )
    {
        typedef typename std::decay< NumStoresArg >::type src_t;
        typedef TypeMethodParamTraits< BeamMonitorTraits<
            ::NS(BeamMonitor) >::particle_index_t >::value_type dest_t;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment<
            src_t, dest_t >( elem->num_stores, num_stores );
    }

    template< typename StartTurnArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_start_turn(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        StartTurnArg start_turn )
    {
        typedef typename std::decay< StartTurnArg >::type src_t;
        typedef TypeMethodParamTraits< BeamMonitorTraits< ::NS(BeamMonitor)
            >::particle_index_t >::value_type dest_t;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment< src_t, dest_t >(
            elem->start_turn, start_turn );
    }

    template< typename SkipArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_skip_turns(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        SkipArg skip_turns )
    {
        typedef typename std::decay< SkipArg >::type src_t;
        typedef TypeMethodParamTraits< BeamMonitorTraits< ::NS(BeamMonitor)
            >::particle_index_t >::value_type dest_t;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment< src_t, dest_t >(
            elem->skip_turns, skip_turns );
    }

    template< typename OutAddrArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_out_address(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        OutAddrArg out_address )
    {
        typedef typename std::decay< OutAddrArg >::type src_t;
        typedef ::NS(belem_address_t) dest_t;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment< src_t, dest_t >(
            elem->out_address, out_address );
    }

    template< typename ParticleIdArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_min_particle_id(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        ParticleIdArg min_particle_id )
    {
        typedef typename std::decay< ParticleIdArg >::type src_t;
        typedef TypeMethodParamTraits< BeamMonitorTraits< ::NS(BeamMonitor)
            >::particle_index_t >::value_type dest_t;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment< src_t, dest_t >(
            elem->min_particle_id, min_particle_id );
    }

    template< typename ParticleIdArg >
    SIXTRL_INLINE arch_status_t BeamMonitor_set_max_particle_id(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        ParticleIdArg max_particle_id )
    {
        typedef typename std::decay< ParticleIdArg >::type src_t;
        typedef TypeMethodParamTraits< BeamMonitorTraits< ::NS(BeamMonitor)
            >::particle_index_t >::value_type dest_t;

        SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
        return SIXTRL_CXX_NAMESPACE::Types_perform_assignment< src_t, dest_t >(
            elem->max_particle_id, max_particle_id );
    }

    SIXTRL_INLINE arch_status_t BeamMonitor_set_is_rolling_flag(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        ::NS(be_monitor_flag_t) const is_rolling_flag ) SIXTRL_NOEXCEPT
    {
        SIXTRL_CXX_NAMESPACE::arch_status_t status =
            SIXTRL_CXX_NAMESPACE::ARCH_STATUS_GENERAL_FAILURE;

        if( elem != SIXTRL_NULLPTR )
        {
            elem->is_rolling_flag = is_rolling_flag;
            status = SIXTRL_CXX_NAMESPACE::ARCH_STATUS_SUCCESS;
        }

        return status;
    }

    SIXTRL_INLINE arch_status_t BeamMonitor_set_is_turn_ordered_flag(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        ::NS(be_monitor_flag_t) const is_turn_ordered_flag ) SIXTRL_NOEXCEPT
    {
        SIXTRL_CXX_NAMESPACE::arch_status_t status =
            SIXTRL_CXX_NAMESPACE::ARCH_STATUS_GENERAL_FAILURE;

        if( elem != SIXTRL_NULLPTR )
        {
            elem->is_turn_ordered_flag = is_turn_ordered_flag;
            status = SIXTRL_CXX_NAMESPACE::ARCH_STATUS_SUCCESS;
        }

        return status;
    }

    SIXTRL_INLINE arch_status_t BeamMonitor_set_is_rolling(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        bool const is_rolling_flag ) SIXTRL_NOEXCEPT
    {
        using flag_t = ::NS(be_monitor_flag_t);
        return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_is_rolling_flag( elem,
            ( is_rolling_flag ) ? flag_t{ 1 } : flag_t{ 0 } );
    }

    SIXTRL_INLINE arch_status_t BeamMonitor_set_is_turn_ordered(
        SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
        bool const is_turn_ordered ) SIXTRL_NOEXCEPT
    {
        using flag_t = ::NS(be_monitor_flag_t);
        return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_is_turn_ordered_flag(
            elem, ( is_turn_ordered ) ? flag_t{ 1 } : flag_t{ 0 } );
    }
}
#endif /* defined( __cplusplus ) */

#if defined( __cplusplus ) && !defined( _GPUCODE )
extern "C" {
#endif /* C++, Host */

SIXTRL_INLINE SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)*
NS(BeamMonitor_preset)( SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)*
    SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    if( elem != SIXTRL_NULLPTR )
    {
        typedef NS(particle_index_t) index_t;

        NS(BeamMonitor_set_num_stores)( elem, ( index_t )0 );
        NS(BeamMonitor_set_start_turn)( elem, ( index_t )0 );
        NS(BeamMonitor_set_skip_turns)( elem, ( index_t )0 );
        NS(BeamMonitor_set_out_address)( elem, ( ::NS(belem_address_t) )0 );
        NS(BeamMonitor_set_min_particle_id)( elem, ( index_t )0 );
        NS(BeamMonitor_set_max_particle_id)( elem, ( index_t )0 );
        NS(BeamMonitor_set_is_rolling)( elem, false );
        NS(BeamMonitor_set_is_turn_ordered)( elem, false );
    }

    return elem;
}

SIXTRL_INLINE void NS(BeamMonitor_init)( SIXTRL_BE_ARGPTR_DEC
    NS(BeamMonitor)* SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    NS(BeamMonitor_preset)( elem );
}

SIXTRL_INLINE void NS(BeamMonitor_init_detailed)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t)  const num_stores,
    NS(particle_index_t)  const start_turn,
    NS(particle_index_t)  const skip_turns,
    NS(be_monitor_flag_t) const out_address,
    NS(particle_index_t)  const min_particle_id,
    NS(particle_index_t)  const max_particle_id,
    NS(be_monitor_flag_t) const is_rolling,
    NS(be_monitor_flag_t) const is_turn_ordered ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );

    NS(BeamMonitor_set_num_stores)( elem, num_stores );
    NS(BeamMonitor_set_start_turn)( elem, start_turn );
    NS(BeamMonitor_set_skip_turns)( elem, skip_turns );
    NS(BeamMonitor_set_out_address)( elem, out_address );
    NS(BeamMonitor_set_min_particle_id)( elem, min_particle_id );
    NS(BeamMonitor_set_max_particle_id)( elem, max_particle_id );
    NS(BeamMonitor_set_is_rolling_flag)( elem, is_rolling );
    NS(BeamMonitor_set_is_turn_ordered_flag)( elem, is_turn_ordered );
}

#if defined( __cplusplus ) && !defined( _GPUCODE )
}
#endif /* C++, Host */

#if defined( __cplusplus )

template< typename NumStoresArg, typename StartTurnArg, typename SkipArg,
          typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
SIXTRL_INLINE void NS(BeamMonitor_init_detailed)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
    OutAddrArg out_address,
    ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
    FlagArg is_rolling, FlagArg is_turn_ordered )
{
    namespace st = SIXTRL_CXX_NAMESPACE;
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );

    st::BeamMonitor_set_num_stores( elem, num_stores );
    st::BeamMonitor_set_start_turn( elem, start_turn );
    st::BeamMonitor_set_skip_turns( elem, skip_turns );
    st::BeamMonitor_set_out_address( elem, out_address );
    st::BeamMonitor_set_min_particle_id( elem, min_particle_id );
    st::BeamMonitor_set_max_particle_id( elem, max_particle_id );
    st::BeamMonitor_set_is_rolling_flag( elem, is_rolling );
    st::BeamMonitor_set_is_turn_ordered_flag( elem, is_turn_ordered );
}

template< typename NumStoresArg, typename StartTurnArg, typename SkipArg,
          typename OutAddrArg, typename ParticleIdArg, typename FlagArg >
SIXTRL_INLINE void NS(BeamMonitor_init)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores, StartTurnArg start_turn, SkipArg skip_turns,
    OutAddrArg out_address,
    ParticleIdArg min_particle_id, ParticleIdArg max_particle_id,
    FlagArg is_rolling, FlagArg is_turn_ordered )
{
    SIXTRL_CXX_NAMESPACE::BeamMonitor_init_detailed( elem, num_stores,
        start_turn, skip_turns, out_address, min_particle_id, max_particle_id,
            is_rolling, is_turn_ordered );
}

#endif /* C++ */

#if defined( __cplusplus ) && !defined( _GPUCODE )
extern "C" {
#endif /* C++, Host */

/* getter API, ptr argument: */

SIXTRL_INLINE NS(particle_index_t) NS(BeamMonitor_num_stores)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return elem->num_stores;
}

SIXTRL_INLINE NS(particle_index_t) NS(BeamMonitor_start_turn)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return elem->start_turn;
}

SIXTRL_INLINE NS(particle_index_t) NS(BeamMonitor_skip_turns)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return elem->skip_turns;
}

SIXTRL_INLINE NS(belem_address_t) NS(BeamMonitor_out_address)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return elem->out_address;
}

SIXTRL_INLINE NS(particle_index_t) NS(BeamMonitor_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return elem->min_particle_id;
}

SIXTRL_INLINE NS(particle_index_t) NS(BeamMonitor_max_particle_id)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return elem->max_particle_id;
}

SIXTRL_INLINE NS(be_monitor_flag_t) NS(BeamMonitor_is_rolling_flag)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return elem->is_rolling_flag;
}

SIXTRL_INLINE NS(be_monitor_flag_t)
NS(BeamMonitor_is_turn_ordered_flag)( SIXTRL_BE_ARGPTR_DEC const
    NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return elem->is_turn_ordered_flag;
}

SIXTRL_INLINE bool NS(BeamMonitor_is_rolling)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return ( elem->is_rolling_flag == ( NS(be_monitor_flag_t) )1 );
}

SIXTRL_INLINE bool NS(BeamMonitor_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC const NS(BeamMonitor) *const
        SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return ( elem->is_turn_ordered_flag == ( NS(be_monitor_flag_t) )1 );
}

#if defined( __cplusplus ) && !defined( _GPUCODE )
}
#endif /* C++, Host */

/* getter API, ref argument: */

#if defined( __cplusplus )

SIXTRL_INLINE SIXTRL_PARTICLE_SET_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorTraits< ::NS(BeamMonitor)
            >::particle_set_t >::const_pointer
NS(BeamMonitor_const_particle_set)( SIXTRL_BE_ARGPTR_DEC const
    ::NS(BeamMonitor) *const SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return ( SIXTRL_PARTICLE_SET_ARGPTR_DEC NS(ParticleSet) const* )(
        uintptr_t )elem->out_address;
}

SIXTRL_INLINE SIXTRL_PARTICLE_SET_ARGPTR_DEC
    SIXTRL_CXX_NAMESPACE::TypeMethodParamTraits<
        SIXTRL_CXX_NAMESPACE::BeamMonitorTraits< ::NS(BeamMonitor)
            >::particle_set_t >::pointer
NS(BeamMonitor_particle_set)( SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)*
    SIXTRL_RESTRICT elem ) SIXTRL_NOEXCEPT
{
    SIXTRL_ASSERT( elem != SIXTRL_NULLPTR );
    return ( SIXTRL_PARTICLE_SET_ARGPTR_DEC NS(ParticleSet)* )(
        uintptr_t )elem->out_address;
}

/* setter API, ptr argument: */

template< typename NumStoresArg >
SIXTRL_INLINE ::NS(arch_status_t) NS(BeamMonitor_set_num_stores)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NumStoresArg num_stores )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_num_stores(
        elem, num_stores );
}

template< typename StartTurnArg >
SIXTRL_INLINE ::NS(arch_status_t) NS(BeamMonitor_set_start_turn)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    StartTurnArg start_turn )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_start_turn(
        elem, start_turn );
}

template< typename SkipArg >
SIXTRL_INLINE ::NS(arch_status_t) NS(BeamMonitor_set_skip_turns)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    SkipArg skip_turns )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_skip_turns(
        elem, skip_turns );
}

template< typename OutAddrArg >
SIXTRL_INLINE ::NS(arch_status_t) NS(BeamMonitor_set_out_address)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    OutAddrArg out_address )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_out_address(
        elem, out_address );
}

template< typename ParticleIdArg >
SIXTRL_INLINE ::NS(arch_status_t) NS(BeamMonitor_set_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    ParticleIdArg min_particle_id )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_min_particle_id(
        elem, min_particle_id );
}

template< typename ParticleIdArg >
SIXTRL_INLINE ::NS(arch_status_t) NS(BeamMonitor_set_max_particle_id)(
    SIXTRL_BE_ARGPTR_DEC ::NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    ParticleIdArg max_particle_id )
{
    return SIXTRL_CXX_NAMESPACE::BeamMonitor_set_max_particle_id(
        elem, max_particle_id );
}

#endif /* C++ */

#if defined( __cplusplus ) && !defined( _GPUCODE )
extern "C" {
#endif /* C++, Host */

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_is_rolling_flag)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(be_monitor_flag_t) const is_rolling_flag ) SIXTRL_NOEXCEPT
{
    NS(arch_status_t) status =
        ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_GENERAL_FAILURE;

    if( elem != SIXTRL_NULLPTR )
    {
        elem->is_rolling_flag = is_rolling_flag;
        status = ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_SUCCESS;
    }

    return status;
}

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_is_turn_ordered_flag)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(be_monitor_flag_t) const is_turn_ordered_flag ) SIXTRL_NOEXCEPT
{
    NS(arch_status_t) status =
        ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_GENERAL_FAILURE;

    if( elem != SIXTRL_NULLPTR )
    {
        elem->is_turn_ordered_flag = is_turn_ordered_flag;
        status = ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_SUCCESS;
    }

    return status;
}

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_is_rolling)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    bool const is_rolling ) SIXTRL_NOEXCEPT
{
    typedef NS(be_monitor_flag_t) flag_t;
    return NS(BeamMonitor_set_is_rolling_flag)(
        elem, ( is_rolling ) ? ( flag_t )1 : ( flag_t )0 );
}

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_is_turn_ordered)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    bool const is_turn_ordered ) SIXTRL_NOEXCEPT
{
    typedef NS(be_monitor_flag_t) flag_t;
    return NS(BeamMonitor_set_is_turn_ordered_flag)(
        elem, ( is_turn_ordered ) ? ( flag_t )1 : ( flag_t )0 );
}

/* setter API, ptr argument: */

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_num_stores)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const num_stores ) SIXTRL_NOEXCEPT
{
    NS(arch_status_t) status =
        ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_GENERAL_FAILURE;

    if( elem != SIXTRL_NULLPTR )
    {
        elem->num_stores = num_stores;
        status = ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_SUCCESS;
    }

    return status;
}

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_start_turn)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const start_turn ) SIXTRL_NOEXCEPT
{
    NS(arch_status_t) status =
        ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_GENERAL_FAILURE;

    if( elem != SIXTRL_NULLPTR )
    {
        elem->start_turn = start_turn;
        status = ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_SUCCESS;
    }

    return status;
}

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_skip_turns)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const skip_turns ) SIXTRL_NOEXCEPT
{
    NS(arch_status_t) status =
        ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_GENERAL_FAILURE;

    if( elem != SIXTRL_NULLPTR )
    {
        elem->skip_turns = skip_turns;
        status = ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_SUCCESS;
    }

    return status;
}

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_out_address)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(belem_address_t) const out_address ) SIXTRL_NOEXCEPT
{
    NS(arch_status_t) status =
        ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_GENERAL_FAILURE;

    if( elem != SIXTRL_NULLPTR )
    {
        elem->out_address = out_address;
        status = ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_SUCCESS;
    }

    return status;
}

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_min_particle_id)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const min_particle_id ) SIXTRL_NOEXCEPT
{
    NS(arch_status_t) status =
        ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_GENERAL_FAILURE;

    if( elem != SIXTRL_NULLPTR )
    {
        elem->min_particle_id = min_particle_id;
        status = ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_SUCCESS;
    }

    return status;
}

SIXTRL_INLINE NS(arch_status_t) NS(BeamMonitor_set_max_particle_id)(
    SIXTRL_BE_ARGPTR_DEC NS(BeamMonitor)* SIXTRL_RESTRICT elem,
    NS(particle_index_t) const max_particle_id ) SIXTRL_NOEXCEPT
{
    NS(arch_status_t) status =
        ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_GENERAL_FAILURE;

    if( elem != SIXTRL_NULLPTR )
    {
        elem->max_particle_id = max_particle_id;
        status = ( NS(arch_status_t) )SIXTRL_ARCH_STATUS_SUCCESS;
    }

    return status;
}

#if defined( __cplusplus ) && !defined( _GPUCODE )
}
#endif /* C++, Host */

#endif /* SIXTRACKLIB_COMMON_BEAM_ELEMENTS_BEAM_MONITOR_BEAM_MONITOR_API_H__ */
